// <reference types="@testing-library/jest-dom" />
import * as React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { describe, it, expect, vi, beforeEach } from "vitest"; // Import from vitest
import IssueBoardView from "./IssueBoardView";
import { ReactViewProps } from "../types";

// Mock the updateMarkdownContent prop
const mockUpdateMarkdownContent = vi.fn();
const mockSwitchToMarkdownView = vi.fn(); // Mock for switchToMarkdownView

const defaultProps: ReactViewProps = {
	filePath: "test.md",
	markdownContent: "", // Start with empty, override in tests
	updateMarkdownContent: mockUpdateMarkdownContent,
	// Add basic mocks for other required props
	app: {} as any, // Provide a minimal mock if specific app methods aren't needed
	plugin: {} as any, // Provide a minimal mock if specific plugin methods aren't needed
	switchToMarkdownView: mockSwitchToMarkdownView, // Use the vi.fn() mock
	// Add mocks for other props if they become necessary for specific tests
	// app: {} as any,
	// plugin: {} as any,
	// switchToMarkdownView: vi.fn(),
};

// Helper to render the component with specific markdown
const renderBoard = (markdown: string) => {
	return render(
		<IssueBoardView {...defaultProps} markdownContent={markdown} />
	);
};

// Basic valid markdown structure with frontmatter
const basicValidMarkdown = `\
---
some: frontmatter
tags: [test]
---

# Group 1

## Card One
- Issue-1
### Items
- Item 1.1
- Item 1.2
### Status
- [ ] Status 1.1
- [x] Status 1.2

## Card Two
### Items
- Item 2.1
### Status
- [ ] Status 2.1

# Group 2

## Card Three
### Items
### Status
`;

const frontmatterOnly = `\
---
some: frontmatter
---
`;

describe("IssueBoardView", () => {
	beforeEach(() => {
		// Reset mocks before each test
		mockUpdateMarkdownContent.mockClear();
		mockSwitchToMarkdownView.mockClear();
		// Reset component's internal state simulation if needed (React Testing Library usually handles this via unmounting)
	});

	it("renders without crashing with basic valid markdown", () => {
		renderBoard(basicValidMarkdown);
		expect(screen.getByText("Group 1")).toBeInTheDocument();
		expect(screen.getByText("Card One")).toBeInTheDocument();
		expect(screen.getByText("Item 1.1")).toBeInTheDocument();
		expect(screen.getByLabelText("Status 1.1")).toBeInTheDocument();
	});

	it('shows "No Issue Groups or Cards Found" message for frontmatter-only content', () => {
		renderBoard(frontmatterOnly);
		// Wait for the initial parse effect to complete
		// Using findByText which includes waitFor
		waitFor(() => {
			expect(
				screen.getByText(/No Issue Groups or Cards Found/i)
			).toBeInTheDocument();
		});
	});

	it("renders groups and cards correctly", () => {
		renderBoard(basicValidMarkdown);
		// Check Groups
		expect(
			screen.getByRole("heading", { level: 1, name: "Group 1" })
		).toBeInTheDocument();
		expect(
			screen.getByRole("heading", { level: 1, name: "Group 2" })
		).toBeInTheDocument();

		// Check Cards within Group 1
		const group1 = screen
			.getByRole("heading", { level: 1, name: "Group 1" })
			.closest("div");
		expect(group1).toHaveTextContent("Card One");
		expect(group1).toHaveTextContent("Card Two");
		expect(group1).not.toHaveTextContent("Card Three"); // Ensure card is in the right group

		// Check Cards within Group 2
		const group2 = screen
			.getByRole("heading", { level: 1, name: "Group 2" })
			.closest("div");
		expect(group2).toHaveTextContent("Card Three");
		expect(group2).not.toHaveTextContent("Card One");

		// Check specific item and status in Card One
		expect(screen.getByText("Item 1.1")).toBeInTheDocument();
		expect(screen.getByLabelText("Status 1.1")).not.toBeChecked();
		expect(screen.getByLabelText("Status 1.2")).toBeChecked();
	});

	it("displays parsing errors when parser returns them", () => {
		// Simulate a markdown structure that the parser identifies as problematic
		// (e.g., missing Items/Status, non-task list under status)
		const markdownWithParsingError = `\
---
valid: frontmatter
---

## Card With Bad Status List
### Items
- Good item
### Status
- This is not a task list item!
- [ ] This one is okay
`;
		renderBoard(markdownWithParsingError);

		// Check for the error container and specific error messages generated by the parser
		expect(
			screen.getByText(/Note Parsing Issues Found:/i)
		).toBeInTheDocument();
		expect(
			screen.getByText(/Non-task list item found under '### Status'/i)
		).toBeInTheDocument();

		// Also check that the valid parts are still rendered
		expect(
			screen.getByText("Card With Bad Status List")
		).toBeInTheDocument();
		expect(screen.getByText("Good item")).toBeInTheDocument();
		expect(screen.getByLabelText("This one is okay")).toBeInTheDocument();
		// The bad item text itself might not be rendered as a status item, depending on parser logic
		expect(
			screen.queryByLabelText("This is not a task list item!")
		).not.toBeInTheDocument();
	});

	it("updates markdown when a status checkbox is clicked", async () => {
		renderBoard(basicValidMarkdown);
		const user = userEvent.setup();

		const checkbox = screen.getByLabelText("Status 1.1");
		expect(checkbox).not.toBeChecked();

		await user.click(checkbox);

		// Check if the mock function was called
		await waitFor(() => {
			expect(mockUpdateMarkdownContent).toHaveBeenCalledTimes(1);
		});

		// Verify the content passed to the update function
		const expectedMarkdownAfterCheck = `\
---
some: frontmatter
tags: [test]
---

# Group 1

## Card One
- Issue-1
### Items
- Item 1.1
- Item 1.2
### Status
- [x] Status 1.1
- [x] Status 1.2

## Card Two
### Items
- Item 2.1
### Status
- [ ] Status 2.1

# Group 2

## Card Three
### Items
### Status`; // Trailing newline might vary, check actual output

		// Check the argument passed to the mock function
		await waitFor(() => {
			// Normalize newlines for comparison robustness
			const actualContent =
				mockUpdateMarkdownContent.mock.calls[0][0].replace(
					/\\r\\n/g,
					"\\n"
				);
			const expectedContent = expectedMarkdownAfterCheck.replace(
				/\\r\\n/g,
				"\\n"
			);
			// Trim trailing whitespace which can be inconsistent
			expect(actualContent.trim()).toEqual(expectedContent.trim());
		});

		// Check if the checkbox is now checked in the DOM (optimistic update)
		await waitFor(() => {
			expect(screen.getByLabelText("Status 1.1")).toBeChecked();
		});
	});

	it("allows editing an item text and saves on blur", async () => {
		renderBoard(basicValidMarkdown);
		const user = userEvent.setup();
		const itemToEdit = screen.getByText("Item 1.1");

		await user.click(itemToEdit);

		const input = screen.getByDisplayValue("Item 1.1");
		expect(input).toBeInTheDocument();

		await user.clear(input);
		await user.type(input, "Updated Item 1.1");
		await user.tab(); // Blur the input

		// Check if the update function was called
		await waitFor(() => {
			expect(mockUpdateMarkdownContent).toHaveBeenCalledTimes(1);
		});

		// Verify the updated content in the DOM (optimistic update)
		await waitFor(() => {
			expect(screen.getByText("Updated Item 1.1")).toBeInTheDocument();
			expect(
				screen.queryByDisplayValue("Updated Item 1.1")
			).not.toBeInTheDocument(); // Input should be gone
		});

		// Verify the content passed to the update function
		const expectedMarkdownAfterEdit = `\
---
some: frontmatter
tags: [test]
---

# Group 1

## Card One
- Issue-1
### Items
- Updated Item 1.1
- Item 1.2
### Status
- [ ] Status 1.1
- [x] Status 1.2

## Card Two
### Items
- Item 2.1
### Status
- [ ] Status 2.1

# Group 2

## Card Three
### Items
### Status`;

		await waitFor(() => {
			const actualContent =
				mockUpdateMarkdownContent.mock.calls[0][0].replace(
					/\\r\\n/g,
					"\\n"
				);
			const expectedContent = expectedMarkdownAfterEdit.replace(
				/\\r\\n/g,
				"\\n"
			);
			expect(actualContent.trim()).toEqual(expectedContent.trim());
		});
	});

	// Add more tests:
	// - Item editing save with Enter (should add new item)
	// - Card expansion toggle
	// - Group expansion toggle
	// - Handling edge cases (e.g., no frontmatter, empty sections)
});
